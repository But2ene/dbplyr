---
title: "dplyr 2.0.0 transition guide"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{dplyr 2.0.0 transition guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This transition guide is aimed at backend authors.
dbplyr 2.0.0 is an important release because it includes a plan to all move backend generics into dbplyr (instead of being a mix of dbplyr and dplyr).
This move has been designed to be as gradual as possible so not there are no sudden breakages and backend authors have plenty of time to make changes.

The current timeline is something like this:

-   dbplyr 2.0.0 provides a new interface for database backends, but the old interface remains as is so existing backends continue to work.
    Backend authors can choose to use the new interface.

-   dbplyr 2.1.0 (released \>= 6 months after dplyr 2.0.0) deprecates the old interface, so that users are encouraged to upgrade backends.

-   dbplyr 2.2.0 (released \>= 12 months after dplyr 2.0.0) removes the old interface so user must upgrade backends.

## 2nd edition

dbplyr 2.0.0 draws inspiration from the idea of an [edition](https://testthat.r-lib.org/articles/third-edition.html) so that for dbplyr to use the new generics with your backend, you need to do two things:

-   Depend on dbplyr 2.0.0 in your `DESCRIPTION`, e.g.
    `Imports: dbplyr (>= 2.0.0)`

-   Provide a method for the `dbplyr_edition` generic that declares you want the second edition:

    ```{r}
    #' @importFrom dbplyr dbplyr_edition
    #' @export
    dbplyr_edition.myConnectionClass <- function(con) 2L
    ```

Next you'll need to update your methods, following the advice below.

## DBI generics

When dbplyr was first created there was much spurious variation across DBI backends, and a layer of shims was need to make dbplyr usable.
Now thanks to the work of Kirill MÃ¼ller and on others on DBITest and friends, these shims are no longer needed in most cases, and dbplyr now calls the DBI generics more directly:

-   `db_write_table()` calls `DBI::dbWriteTable()` instead of nine generics that formerly each did a small part of this: `db_create_indexes()`, `db_begin()`, `db_rollback()`, `db_commit()`, `db_list_tables()`, `db_drop_table()`, `db_has_table()`, `db_create_table()`, and `db_data_types()`. Since these generics are no longer used, you can delete their methods from your package. (And if dplyr no longer works, you'll need to fix the `dbWriteTable()` method).
-   `dbplyr::sql_escape_ident()` and `dbplyr::sql_escape_string()` are no longer used in favour of calling `dbQuoteIdentifer()` and `dbQuoteString()` directly. If you've provided those methods, you'll need to move their implementation to methods for the DBI generics.

Making these changes are important because they ensure your backend works consistently whether you use it through DBI or dplyr.

## SQL generation

There are a number of dplyr generics that basically generate SQL and then execute it.
Now rather than implementation method for a `db_*` generic from dplyr, you can implement a method for a `sql_*` generic from dbplyr.

If you have any of the following generics, extract the SQL generation code into a new `sql_` method:

    db_create_index   -> sql_index_create
    db_analyze        -> sql_table_analyze
    db_query_rows     -> sql_query_rows
    db_save_query     -> sql_query_save
    db_explain        -> sql_query_explain

Again, you'll need to keep your old `db_` method (so your package continues to work with dbplyr 1.0.0), but you may want to use your new `sql_` method from it to avoid code duplication.

Eventually, dbplyr will stop calling the `db_` generic and will call the `sql_` generics directly.

## Renamed generics

## Conditional method registration

To make it possible to release your package to CRAN before dbplyr 2.0.0 is out (providing the best experience for your users), you can rely on the usual `@export` roxygen tag or `S3method()` `NAMESPACE` directive because that requires importing the generic (which won't be available until after dbplyr 2.0.0 is available).

```{r}
.onLoad <- function(...) {
  if (packageVersion("dbplyr" >= "1.99")) {
    s3_register("dbplyr::sql_index_create", "backend_class")
    s3_register("dbplyr::sql_table_analyze", "backend_class")
  }
}

s3_register <- function(generic, class, method = NULL) {
  stopifnot(is.character(generic), length(generic) == 1)
  stopifnot(is.character(class), length(class) == 1)

  pieces <- strsplit(generic, "::")[[1]]
  stopifnot(length(pieces) == 2)
  package <- pieces[[1]]
  generic <- pieces[[2]]

  caller <- parent.frame()

  get_method_env <- function() {
    top <- topenv(caller)
    if (isNamespace(top)) {
      asNamespace(environmentName(top))
    } else {
      caller
    }
  }
  get_method <- function(method, env) {
    if (is.null(method)) {
      get(paste0(generic, ".", class), envir = get_method_env())
    } else {
      method
    }
  }

  method_fn <- get_method(method)
  stopifnot(is.function(method_fn))

  # Always register hook in case package is later unloaded & reloaded
  setHook(
    packageEvent(package, "onLoad"),
    function(...) {
      ns <- asNamespace(package)

      # Refresh the method, it might have been updated by `devtools::load_all()`
      method_fn <- get_method(method)

      registerS3method(generic, class, method_fn, envir = ns)
    }
  )

  # Avoid registration failures during loading (pkgload or regular)
  if (!isNamespaceLoaded(package)) {
    return(invisible())
  }

  envir <- asNamespace(package)

  # Only register if generic can be accessed
  if (exists(generic, envir)) {
    registerS3method(generic, class, method_fn, envir = envir)
  }

  invisible()
}
```

(`s3_register()` is licensed with [the unlicense](https://choosealicense.com/licenses/unlicense/) so you're free to copy and paste into your package, and there's no need to acknowledge the contribution.
Learn more about it at `?vctrs::s3_register`.)

At some point in the future, you can formally require version 2.0.0 of dbplyr in your `DESCRIPTION`, and then delete this code, switching back to your usual way of exporting methods.
